<!DOCTYPE html>
<html lang="en">
<head>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>
	$(function() {
		$('#ins').click(function() {
			$('#javaSec').html(`
			import java.lang.reflect.*;
			import java.util.ArrayList;
			import java.util.Arrays;
			import java.util.LinkedList;
			import java.util.List;

			public class Inspector{

			    static final String[] PRIMITIVE_TYPE_NAMES = {"byte", "int", "short","long","boolean","double","float","char"};
			    static LinkedList<Object> checked_things = new LinkedList<>();


			    public void inspect(Object obj, boolean recursive){
			        if(obj == null){
			            //System.out.println("    Cannot inspect a null object");
			            return;
			        }
			        if(checked_things.contains(obj)){
			            System.out.println("#### ALREADY INSPECTED " + obj + ". CONTINUING... ####");
			            return;
			        }
			        System.out.println("#### Currently Inspecting: " + obj + " with recursive set to: " + recursive + " ####\n");

			        LinkedList toCheckRecursively = new LinkedList();
			        Class classObj = obj.getClass();

			        if(!classObj.isArray()){

			            inspectNonArray(classObj, obj, toCheckRecursively);

			            if(classObj.getSuperclass() != null){

			                inspectSuperClassDetails(classObj, obj, toCheckRecursively);
			            }
			            if(classObj.isInterface()) {
			                Class[] interf = classObj.getInterfaces();

			                for (int i = 0; i < interf.length; i++) {
			                    inspectSuperInterfaces(classObj, interf[i], toCheckRecursively);
			                }

			            }
			            if(recursive){
			                System.out.println("#### Inspecting Recursive Fields & Objects for: " + obj + " ####");

			                recursiveInspection(obj, recursive, toCheckRecursively);
			            }
			            checked_things.add(obj);
			        }
			        else{
			            inspectArray(obj, recursive);
			        }
			    }

			    private void inspectArray(Object obj, boolean recursive) {
			        boolean skipPrimitive = false;
			        Class componentName = obj.getClass().getComponentType();
			        for(int j = 0; j < PRIMITIVE_TYPE_NAMES.length ; j++) {
			            if (PRIMITIVE_TYPE_NAMES[j].equals(componentName.getName())) {
			                // we have an array of primitive type
			                System.out.print("    FOUND PRIMITIVE ARRAY OF TYPE: " + componentName + " WITH VALUES: {");
			                ArrayList<String> foundPrimitives = new ArrayList<>();
			                for (int i = 0; i < Array.getLength(obj); i++) {
			                    foundPrimitives.add(""  + Array.get(obj, i));
			                }
			                System.out.println(String.join(",", foundPrimitives) + "}\n\n");

			                skipPrimitive = true;
			            }
			        }
			        if(!skipPrimitive) {
			            for(int i = 0; i < Array.getLength(obj); i++) {
			                inspect(Array.get(obj, i), recursive);
			            }
			        }
			    }

			    private void inspectSuperInterfaces(Class classObj, Class interf, LinkedList toCheckRecursively) {
			        String supersMethods = inspectMethods(interf);
			        String supersConstructors = inspectConstructors(interf);
			        String supersFields = inspectFields(interf, classObj, toCheckRecursively);

			        printInterfaceDetails(interf, supersMethods, supersConstructors, supersFields);
			    }

			    private void inspectSuperClassDetails(Class classObj, Object obj, LinkedList toCheckRecursively) {
			        String supersMethods = inspectMethods(classObj.getSuperclass());
			        String supersConstructors = inspectConstructors(classObj.getSuperclass());
			        String supersFields = inspectFields(classObj.getSuperclass(), classObj, toCheckRecursively);

			        printSuperClassDetails(classObj, supersMethods, supersConstructors, supersFields);
			    }

			    private void inspectNonArray(Class classObj, Object obj, LinkedList toCheckRecursively) {
			        String declaringClass = inspectDeclaringClass(classObj);
			        String immediateSuperClass = inspectImmediateSuperClass(classObj);
			        String className = classObj.getName();
			        String interfaces = inspectInterfaces(classObj);
			        String methods = inspectMethods(classObj);
			        String constructors = inspectConstructors(classObj);
			        String fields = inspectFields(classObj, obj, toCheckRecursively);

			        printClassObjDetails(declaringClass, immediateSuperClass, className, interfaces, methods, constructors, fields);
			    }

			    private void printInterfaceDetails(Class interf, String supersMethods, String supersConstructors, String supersFields) {
			        System.out.println("#### Inspecting SuperInterface ####\n");
			        System.out.println("#### Inspecting SuperInterface Methods ####");
			        System.out.println("    Methods for " + interf.getName() + " are: \n         " + supersMethods + "\n\n");
			        System.out.println("#### Inspecting SuperClass Constructors ####");
			        System.out.println("    Constructors for " + interf.getName() + " are: \n     " + supersConstructors + "\n\n");
			        System.out.println("#### Inspecting SuperClass Fields ####");
			        System.out.println("    Fields for " + interf.getName() + " are: " + supersFields + "\n\n");
			    }

			    private void printSuperClassDetails(Class classObj, String supersMethods, String supersConstructors, String supersFields) {
			        System.out.println("#### Inspecting SuperClass ####\n");
			        System.out.println("#### Inspecting SuperClass Methods ####");
			        System.out.println("    Methods for " + classObj.getSuperclass().getName() + " are: \n         " + supersMethods + "\n\n");
			        System.out.println("#### Inspecting SuperClass Constructors ####");
			        System.out.println("    Constructors for " + classObj.getSuperclass().getName() + " are: \n         " + supersConstructors + "\n\n");
			        System.out.println("#### Inspecting SuperClass Fields ####");
			        System.out.println("    Fields for " + classObj.getSuperclass().getName() + " are: " + supersFields + "\n\n");
			    }

			    private void printClassObjDetails(String declaringClass, String immediateSuperClass, String className, String interfaces, String methods, String constructors, String fields) {
			        System.out.println("#### Inspecting Declaring Class ####");
			        System.out.println("    Declaring Class for " + className + " is: " + declaringClass + "\n\n");
			        System.out.println("#### Inspecting Super Class ####");
			        System.out.println("    Super Class for " + className + " is: " + immediateSuperClass + "\n\n");
			        System.out.println("#### Inspecting Interfaces ####");
			        System.out.println("    Interfaces for " + className + " are: " + interfaces + "\n\n");
			        System.out.println("#### Inspecting Methods ####");
			        System.out.println("    Methods for " + className + " are: \n         " + methods + "\n\n");
			        System.out.println("#### Inspecting Constructors ####");
			        System.out.println("    Constructors for " + className + " are: \n         " + constructors + "\n\n");
			        System.out.println("#### Inspecting Fields ####");
			        System.out.println("    Fields for " + className + " are: \n         " + fields + "\n\n");
			    }

			    public void recursiveInspection(Object obj, boolean recursive, LinkedList toCheckRecursively){
			        if(toCheckRecursively.size() == 0){
			            System.out.println("    Nothing to inspect. Continuing...");
			            return;
			        }
			        for(int i = 0; i < toCheckRecursively.size(); i++){
			            Field field = (Field) toCheckRecursively.get(i);
			            field.setAccessible(true);
			            System.out.println("    #### Currently inspecting " + field.getName() + " ####\n");
			            try {
			                inspect(field.get(obj), recursive);
			                checked_things.add(obj);
			            }
			            catch(NullPointerException e){
			                System.out.println("    COULD NOT GET NULL FROM OBJECT. CONTINUING...");
			            }
			            catch(IllegalAccessException e){
			                System.out.println("    COULD NOT ACCESS FIELD FROM OBJECT. CONTINUING...");
			            }
			        }
			    }

			    public String inspectFields(Class classObj, Object obj, LinkedList toCheckRecursively){
			        String fieldsResult = "";
			        Field[] fields = classObj.getDeclaredFields();
			        for(int i = 0; i < fields.length; i++){
			            fields[i].setAccessible(true);
			            if(!fields[i].getType().isPrimitive() && fields[i] != null){
			                toCheckRecursively.add(fields[i]);
			            }
			            String type = fields[i].getType().getName();
			            String modifier = Modifier.toString(fields[i].getModifiers());
			            fieldsResult = fieldsResult + "\n";
			            fieldsResult = fieldsResult + "         " + fields[i].getName() + "\n";
			            fieldsResult = fieldsResult + "             type: " + type + "\n";
			            fieldsResult = fieldsResult + "             modifiers: " + modifier + "\n";
			            try {
			                fieldsResult = fieldsResult + "             value: " + fields[i].get(obj);
			            }
			            catch(Exception e){
			                fieldsResult = fieldsResult + "             Could not get value due to permissions";
			            }
			            if(fields[i].getType().isArray()){
			                fieldsResult = fieldsResult + "\n";
			                fieldsResult = fieldsResult + "         " + fields[i].getName() + " is an array with the following properties: \n";
			                fieldsResult = fieldsResult + "             Contains Type: " + fields[i].getType().getComponentType().getName() + "\n";
			                try {
			                    fieldsResult = fieldsResult + "             Length: " + Array.getLength(fields[i].get(obj)) +"\n";
			                }
			                catch (Exception e){
			                    fieldsResult = fieldsResult + "             Could not access length\n";
			                }
			                fieldsResult = fieldsResult + "             Elements: {";
			                try {
			                    for (int j = 0; j < Array.getLength(fields[i].get(obj)); j++) {
			                        Object ele = Array.get(fields[i].get(obj), j);
			                        fieldsResult = fieldsResult + ele + ", ";

			                    }
			                    if(Array.getLength(fields[i].get(obj)) != 0){
			                        fieldsResult = fieldsResult.trim();
			                        fieldsResult = fieldsResult.substring(0, fieldsResult.length() - 1);
			                    }
			                    fieldsResult = fieldsResult + "}";

			                }
			                catch(IllegalArgumentException e){
			                    e.printStackTrace();
			                    fieldsResult = fieldsResult + "Expected Array: got type " + fields[i].getType() + "}".toUpperCase();
			                }
			                catch(IllegalAccessException e){
			                    fieldsResult = fieldsResult + "Could not access elements}".toUpperCase();
			                }
			            }
			        }

			        return fieldsResult;
			    }

			    public String inspectConstructors(Class classObj){
			        String constrResult = "";
			        Constructor[] cArr = classObj.getConstructors();
			        for(int i = 0; i < cArr.length; i++){
			            cArr[i].setAccessible(true);
			            Class[] params = cArr[i].getParameterTypes();
			            String modifies = Modifier.toString(cArr[i].getModifiers());
			            constrResult = constrResult + "\n";
			            constrResult = constrResult + "         " + cArr[i].getName() + "(";
			            for(int j = 0; j < params.length; j++){
			                constrResult = constrResult + params[j].getName() + ", ";
			            }
			            if(params.length != 0){
			                constrResult = constrResult.trim();
			                constrResult = constrResult.substring(0, constrResult.length() - 1);
			            }
			            constrResult = constrResult + ")\n";
			            constrResult = constrResult + "           with modifiers: " + modifies;
			        }

			        return constrResult;
			    }

			    public String inspectMethods(Class classObj){
			        String methodsResult = "";
			        Method[] mArr = classObj.getMethods();
			        for(int i = 0; i < mArr.length; i++){
			            mArr[i].setAccessible(true);
			            Class[] execps = mArr[i].getExceptionTypes();
			            Class[] params = mArr[i].getParameterTypes();
			            Class rtype = mArr[i].getReturnType();
			            String modifies = Modifier.toString(mArr[i].getModifiers());
			            methodsResult = methodsResult + "\n";
			            methodsResult = methodsResult + "         " + mArr[i].getName() + "\n";
			            methodsResult = methodsResult + "             exceptions: ";
			            for(int j = 0; j < execps.length; j++){
			                methodsResult = methodsResult + execps[j].getName() + ", ";
			            }
			            if (execps.length != 0) {
			                methodsResult = methodsResult.trim();
			                methodsResult = methodsResult.substring(0, methodsResult.length() - 1);
			            }
			            methodsResult = methodsResult + "\n             parameters: ";
			            for(int j = 0; j < params.length; j++){
			                methodsResult = methodsResult + params[j].getName() + ", ";
			            }
			            if(params.length != 0){
			                methodsResult = methodsResult.trim();
			                methodsResult = methodsResult.substring(0, methodsResult.length() - 1);
			            }
			            methodsResult = methodsResult + "\n             return type: ";
			            methodsResult = methodsResult + rtype.getName();
			            methodsResult = methodsResult + "\n             modifiers: ";
			            methodsResult = methodsResult + modifies;
			        }

			        return methodsResult;
			    }

			    public String inspectInterfaces(Class classObj) {
			        Class[] interArr = classObj.getInterfaces();
			        String interfaceResult = "";
			        if(interArr.length < 1){
			            return "No implemented interfaces";
			        }
			        else{
			            for(int i = 0; i < interArr.length; i++){
			                interfaceResult = interfaceResult + interArr[i].getName() + ", ";
			            }
			            interfaceResult = interfaceResult.trim();
			            interfaceResult = interfaceResult.substring(0, interfaceResult.length() - 1);
			            return interfaceResult;
			        }
			    }

			    public String inspectDeclaringClass(Class classObj){
			        return classObj.getName();
			    }

			    public String inspectImmediateSuperClass(Class classObj){
			        return classObj.getSuperclass().getName();
			    }
			}`);	
		});
		$('#ri').click(function() {
			$('#javaSec').html(`
			import java.lang.reflect.*;
			import java.util.ArrayList;
			import java.util.LinkedList;
			import java.util.List;

			public class ReflectiveInspector {

			        public List<String> already_visited_class = new ArrayList<>();

			        public void inspect(Object obj, boolean recursive) throws IllegalAccessException {
			            if(obj == null){
			                System.out.println("Cannot operate on a NULL object. Exiting now...");
			                return;
			            }
			            LinkedList recursiveList = new LinkedList();
			            Class classObj = obj.getClass();
			            if(already_visited_class.contains(classObj.getTypeName())){
			                return;
			            }
			            System.out.println("Currently inspecting object of type: " + classObj.getTypeName());
			            System.out.println("Recursive option is set to: " + recursive);

			            if(classObj.isPrimitive()){
			                System.out.println("Currently inspecting primitive object: " + classObj.getTypeName());
			                //Do Some work
			            }
			            else if(!classObj.isArray()){
			                System.out.println("Declaring Class: " + getDeclaringClass(classObj));

			                getInterface(obj,classObj, recursiveList, recursive);
			                getMethods(classObj);
			                getConstructors(classObj);
			                getFields(obj,classObj, recursiveList, recursive);
			                getFieldValue(classObj);
			                already_visited_class.add(classObj.getTypeName());
			                if(recursiveList.size() > 0){
			                    getRecursive(obj,classObj, recursiveList, recursive);
			                }

			                if(recursive){
			                    if(classObj.isPrimitive()){
			                        recursive = false;
			                    }
			                    getRecursive(obj,classObj, recursiveList, recursive);
			                }
			            }
			            else{
			                for(int i = 0; i < Array.getLength(obj); i++){
			                /*Have to do this recursively because we need to go through every element of the array (Which could
			                also be an array, but we have no way of knowing until runtime)
			                 */
			                    inspect(Array.get(obj, i), recursive);
			                }
			            }

			        }

			        public void getRecursive(Object obj,Class classObj, LinkedList recursiveList, boolean recursive) throws IllegalAccessException {
			            if(recursiveList.size() == 0){ return;}
			            System.out.println("Recursively inspecting: " + classObj.getName());
			            for(int i = 0; i < recursiveList.size(); i++){
			                Field f = (Field) recursiveList.get(i);
			                System.out.println("    Lets deep dive into: " + f.getName());
			                if(recursive){
			                    inspect(f.get(obj), recursive);
			                }

			            }
			        }

			        public void getMethods(Class classObj){
			            Method[] mArr= classObj.getMethods();
			            System.out.println("Methods of " + classObj.getName() + " are: ");
			            for(int i = 0; i < mArr.length; i++){
			                System.out.println("    " + mArr[i].getName());
			            }
			            System.out.println("\n\n");
			            for(int i = 0; i < mArr.length; i++){
			                Method method = mArr[i];
			                System.out.println("    " + method.getName() + " has the following exceptions: ");
			                for(int j = 0; j < method.getExceptionTypes().length; j++){
			                    System.out.println("        " + method.getExceptionTypes()[j].getName());
			                }
			                System.out.println("    " + method.getName() + " has the following parameter types: ");
			                for(int j = 0; j < method.getParameters().length; j++){
			                    System.out.println("        " + method.getParameters()[j].getParameterizedType());
			                }
			                System.out.println("    " + method.getName() + " has the following return type: " + method.getReturnType());
			                System.out.println("    " + method.getName() + " has the following modifiers: " + Modifier.toString(method.getModifiers()));
			                System.out.print("\n\n");
			            }
			        }

			        public void getConstructors(Class classObj){
			            Constructor[] conArr = classObj.getConstructors();
			            System.out.println("Constructors of " + classObj.getName() + " are: ");
			            for(int i = 0; i < conArr.length; i++){
			                System.out.println("    " + conArr[i].getName() + "(" + conArr[i].getParameterCount()+ ")");
			            }
			            System.out.println("\n");
			            for(int i = 0; i < conArr.length; i++){
			                Constructor constructor = conArr[i];
			                System.out.println("    " + constructor.getName()+ "(" + conArr[i].getParameterCount()+ ")" + " has the following parameter types: ");
			                for(int j = 0; j < constructor.getParameters().length; j++){
			                    System.out.println("        " + constructor.getParameters()[j].getParameterizedType());
			                }
			                System.out.println("    " + constructor.getName()+ "(" + conArr[i].getParameterCount()+ ")" + " has the following modifiers: " + Modifier.toString(constructor.getModifiers()));
			                System.out.println("\n");
			            }
			        }

			        public void getFields(Object obj, Class classObj, LinkedList recursiveList, boolean recursive) throws IllegalAccessException {
			            Field[] fArr = classObj.getDeclaredFields();
			            System.out.println("Fields of " + classObj.getName() + " are: ");
			            if( fArr == null){
			                return;
			            }
			            for(int i = 0; i < fArr.length; i++){
			                Field field= fArr[i];
			                if(field == null){ continue;}
			                try {
			                    field.setAccessible(true);
			                    if (!field.getType().isPrimitive()) {
			                        recursiveList.add(field);
			                    }
			                    System.out.println("    " + field.getName());
			                    System.out.println("        " + field.getName() + " has the following type: " + field.getType().getName());
			                    System.out.println("        " + field.getName() + " has the following modifiers: " + Modifier.toString(field.getModifiers()));
			                    if (field.getType() == null && !recursive) {
			                        System.out.println("        " + field.getName() + " is a reference with value: " + field.getClass() + field.hashCode());
			                    } else {
			                        System.out.println("        " + field.getName() + " has value of: " + field.get(obj));
			                    }
			                    if (field.getType().isArray() && field.get(obj) != null) {
			                        System.out.println("        " + field.getName() + " is an array with the following properties: ");
			                        System.out.println("            Length: " + Array.getLength(field.get(obj)));
			                        System.out.println("            Contains type: " + field.getType().getComponentType().getName());
			                        System.out.println("            Elements: ");
			                        for (int j = 0; j < Array.getLength(field.get(obj)); j++) {
			                            System.out.println("                " + Array.get(field.get(obj), j));
			                        }
			                    }
			                }
			                catch(InaccessibleObjectException e){
			                    System.out.println("Unable to access" + field.getName() + ". Continuing...");
			                }

			            }
			        }

			        public void getFieldValue(Class classObj){
			            return;
			        }

			        public void getInterface(Object obj,Class classObj, LinkedList recursiveList, boolean recursive) throws IllegalAccessException {
			            Class[] cArr = classObj.getInterfaces();
			            if(!classObj.isInterface()){
			                System.out.println("Implemented Interfaces: ");
			                for(int i = 0; i < cArr.length; i++){
			                    System.out.println("    " + cArr[i].getName());
			                }
			            }
			            else{
			                for(int i = 0; i < cArr.length; i++){
			                    getMethods(cArr[i]);
			                    getConstructors(cArr[i]);
			                    getFields(obj,cArr[i], recursiveList, recursive);
			                    getFieldValue(cArr[i]);
			                }
			            }
			        }

			        public void getImmSuperClass(Object obj,Class classObj, LinkedList recursiveList, boolean recursive) throws IllegalAccessException {
			            Class superc = classObj.getSuperclass();
			            System.out.println("Immediate Superclass: " + superc.getName());
			            System.out.println("Superclass has the following properties: ");
			            if(superc != null) {
			                getMethods(superc);
			                getConstructors(superc);
			                getFields(obj,superc, recursiveList, recursive);
			                getFieldValue(superc);
			            }
			        }

			        public String getDeclaringClass(Class classObj) {
			            return classObj.getName();
			        }
			}`);
		});
		$('#it').click(function() {
			$('#javaSec').html(`import org.junit.After;
			import org.junit.Before;
			import org.junit.jupiter.api.Test;
			import java.io.ByteArrayOutputStream;
			import java.io.PrintStream;
			import java.lang.reflect.*;
			import java.util.LinkedList;

			import static org.hamcrest.core.StringStartsWith.startsWith;
			import static org.junit.jupiter.api.Assertions.*;


			class InspectorTest {
			    int[] intArr = {1,2,3,4};
			    int[][] intArr2D = {{1,2,3},{4,5,6}};
			    byte[] byteArr = {80, 101, 32, 45, 76};
			    Object[] objArr = {3, "Hello", 1.0, 3.1415927892837848, intArr, intArr2D, byteArr};
			    Inspector ins = new Inspector();
			    @Test
			    void testDeclaringClass() {
			        for(int i = 0; i < objArr.length; i++){
			            assertEquals(objArr[i].getClass().getName(), ins.inspectDeclaringClass(objArr[i].getClass()));
			        }
			    }

			    @Test
			    void testSuperClass() {
			        for(int i = 0; i < objArr.length; i++){
			            assertEquals(objArr[i].getClass().getSuperclass().getName(), ins.inspectImmediateSuperClass(objArr[i].getClass()));
			        }
			    }

			    @Test
			    void testInterfaces() {
			        for(int i = 0; i < objArr.length; i++){
			            String result = "";
			            Class[] interArr = objArr[i].getClass().getInterfaces();
			            for(int j = 0; j < interArr.length; j++) {
			                result = result + interArr[j].getName() + ", ";
			            }
			                result = result.trim();
			                result = result.substring(0, result.length() - 1);
			                assertEquals(result, ins.inspectInterfaces(objArr[i].getClass()));
			        }
			    }

			    @Test
			    void testMethods() {
			        for(int i = 0; i < objArr.length; i++){
			            String result = "";
			            Method[] mArr = objArr[i].getClass().getMethods();
			            for(int x = 0; x < mArr.length; x++) {
			                Class[] execps = mArr[x].getExceptionTypes();
			                Class[] params = mArr[x].getParameterTypes();
			                Class rtype = mArr[x].getReturnType();
			                String modifies = Modifier.toString(mArr[x].getModifiers());
			                result = result + "\n";
			                result = result + "         " + mArr[x].getName() + "\n";
			                result = result + "             exceptions: ";
			                for(int j = 0; j < execps.length; j++){
			                    result = result + execps[j].getName() + ", ";
			                }
			                if (execps.length != 0) {
			                    result = result.trim();
			                    result = result.substring(0, result.length() - 1);
			                }
			                result = result + "\n             parameters: ";
			                for(int j = 0; j < params.length; j++){
			                    result = result + params[j].getName() + ", ";
			                }
			                if(params.length != 0){
			                    result = result.trim();
			                    result = result.substring(0, result.length() - 1);
			                }
			                result = result + "\n             return type: ";
			                result = result + rtype.getName();
			                result = result + "\n             modifiers: ";
			                result = result + modifies;
			            }
			            assertEquals(result, ins.inspectMethods(objArr[i].getClass()));
			        }
			    }

			    @Test
			    void testConstructors() {
			        for(int i = 0; i < objArr.length; i++) {
			            String result = "";
			            Constructor[] constr = objArr[i].getClass().getConstructors();
			            for(int x = 0; x < constr.length; x++){
			                Class[] params = constr[x].getParameterTypes();
			                String modifies = Modifier.toString(constr[x].getModifiers());
			                result = result + "\n";
			                result = result + "         " + constr[x].getName() + "(";
			                for(int j = 0; j < params.length; j++){
			                    result = result + params[j].getName() + ", ";
			                }
			                if(params.length != 0){
			                    result = result.trim();
			                    result = result.substring(0, result.length() - 1);
			                }
			                result = result + ")\n";
			                result = result + "           with modifiers: " + modifies;
			            }
			            assertEquals(result, ins.inspectConstructors(objArr[i].getClass()));
			        }
			    }

			    @Test
			    void testFields() {
			        for(int i = 0; i < objArr.length; i++){
			            String result = "";
			            Field[] fields = objArr[i].getClass().getDeclaredFields();
			            for(int j = 0; j < fields.length; j++){
			                fields[j].setAccessible(true);
			                String type = fields[j].getType().getName();
			                String modifier = Modifier.toString(fields[j].getModifiers());
			                result = result + "\n";
			                result = result + "         " + fields[j].getName() + "\n";
			                result = result + "             type: " + type + "\n";
			                result = result + "             modifiers: " + modifier + "\n";
			                try {
			                    result = result + "             value: " + fields[j].get(objArr[i]);
			                }
			                catch(Exception e){
			                    result = result + "             Could not get value due to permissions";
			                }
			                if(fields[j].getType().isArray()) {
			                    result = result + "\n";
			                    result = result + "         " + fields[j].getName() + " is an array with the following properties: \n";
			                    result = result + "             Contains Type: " + fields[j].getType().getComponentType().getName() + "\n";
			                    try {
			                        result = result + "             Length: " + Array.getLength(fields[j].get(objArr[i])) + "\n";
			                    } catch (Exception e) {
			                        result = result + "             Could not access length\n";
			                    }
			                    result = result + "             Elements: {";
			                    try {
			                        for (int k = 0; k < Array.getLength(fields[j].get(objArr[i])); k++) {
			                            Object ele = Array.get(fields[j].get(objArr[i]), k);
			                            result = result + ele + ", ";

			                        }
			                        if (Array.getLength(fields[j].get(objArr[i])) != 0) {
			                            result = result.trim();
			                            result = result.substring(0, result.length() - 1);
			                        }
			                        result = result + "}";

			                    } catch (IllegalArgumentException e) {
			                        e.printStackTrace();
			                        result = result + "Expected Array: got type " + fields[j].getType() + "}".toUpperCase();
			                    } catch (IllegalAccessException e) {
			                        result = result + "Could not access elements}".toUpperCase();
			                    }
			                }
			            }
			            assertEquals(result.trim(), ins.inspectFields(objArr[i].getClass(), objArr[i], new LinkedList()).trim());
			        }
			    }

			}`);
		});
	});
</script>






<title>Josh Dow</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
* {
  box-sizing: border-box;
}
/* Style the body */
body {
  font-family: Arial, Helvetica, sans-serif;
  margin: 0;
}

/* Header/logo Title */
.header {
  padding: 35px;
  text-align: center;
  background: darkred;
  color: gold;
}

/* Increase the font size of the heading */
.header h1 {
  font-size: 40px;
}

/* Sticky navbar - toggles between relative and fixed, depending on the scroll position. It is positioned relative until a given offset position is met in the viewport - then it "sticks" in place (like position:fixed). The sticky value is not supported in IE or Edge 15 and earlier versions. However, for these versions the navbar will inherit default position */
.navbar {
  overflow: hidden;
  background-color: black;
  position: sticky;
  position: -webkit-sticky;
  top: 0;
}

/* Style the navigation bar links */
.navbar a {
  float: left;
  display: block;
  color: gold;
  text-align: center;
  padding: 14px 20px;
  text-decoration: none;
}


/* Right-aligned link */
.navbar a.right {
  float: right;
}

/* Change color on hover */
.navbar a:hover {
  background-color: gold;
  color: darkred;
}

/* Active/current link */
.navbar a.active {
  background-color: white;
  color: darkred;
}

/* Column container */
.row {  
  display: -ms-flexbox; /* IE10 */
  display: flex;
  -ms-flex-wrap: wrap; /* IE10 */
  flex-wrap: wrap;
}

/* Create two unequal columns that sits next to each other */
/* Sidebar/left column */
.side {
  -ms-flex: 30%; /* IE10 */
  flex: 30%;
  background-color: #f1f1f1;
  padding: 20px;
}

/* Main column */
.main {   
  -ms-flex: 70%; /* IE10 */
  flex: 70%;
  background-color: white;
  padding: 20px;
  overflow: scroll;
}

/* Fake image, just for this example */
.fakeimg {
  background-color: #aaa;
  width: 100%;
  padding: 20px;
}

/* Footer */
.footer {
  position: absolute;
  right: 0;
  bottom: 0;
  left: 0;
  padding: 20px;
  text-align: center;
  background: #009;
}

/* Style the tab */
.tab {
  float: left;
  border: 1px solid #ccc;
  background-color: #f1f1f1;
  width: 30%;
  height: 300px;
}

/* Style the buttons that are used to open the tab content */
.tab button {
  display: block;
  background-color: inherit;
  color: black;
  padding: 22px 16px;
  width: 100%;
  border: none;
  outline: none;
  text-align: left;
  cursor: pointer;
  transition: 0.3s;
}

/* Change background color of buttons on hover */
.tab button:hover {
  background-color: #ddd;
}

/* Create an active/current "tab button" class */
.tab button.active {
  background-color: #ccc;
}

/* Style the tab content */
.tabcontent {
  float: left;
  padding: 0px 12px;
  border: 1px solid #ccc;
  width: 70%;
  border-left: none;
  height: 300px;
}
.tabcontent2 {
  float: left;
  padding: 0px 12px;
  border: 1px solid #ccc;
  width: 70%;
  border-left: none;
  height: 300px;
}
.navbar2 a {
  float: left;
  display: block;
  color: black;
  text-align: center;
  padding: 14px 20px;
  text-decoration: none;
  font-size: 12px;
}


/* Right-aligned link */
.navbar2 a.right {
  float: right;
}

/* Change color on hover */
.navbar2 a:hover {
  background-color: darkred;
  color: gold;
}

/* Active/current link */
.navbar2 a.active {
  background-color: black;
  color: white;
}
.dropdown {
  float: left;
  overflow: hidden;
}

.dropdown .dropbtn {
  font-size: 16px;  
  border: none;
  outline: none;
  color: white;
  padding: 14px 16px;
  background-color: inherit;
  font-family: inherit;
  margin: 0;
}
.dropdown-content {
  display: none;
  position: absolute;
  background-color: #f9f9f9;
  min-width: 160px;
  box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
  z-index: 1;
}

.dropdown-content a {
  float: none;
  color: black;
  padding: 12px 16px;
  text-decoration: none;
  display: block;
  text-align: left;
}

.dropdown-content a:hover {
  background-color: #ddd;
}

.dropdown:hover .dropdown-content {
  display: block;
}

.third-level-menu
{
    position: absolute;
    top: 0;
    right: -150px;
    width: 150px;
    list-style: none;
    padding: 0;
    margin: 0;
    display: none;
}

.third-level-menu > li
{
    height: 30px;
    background: #999999;
}
.third-level-menu > li:hover { background: #CCCCCC; }

.second-level-menu
{
    position: absolute;
    top: 30px;
    left: 0;
    width: 150px;
    list-style: none;
    padding: 0;
    margin: 0;
    display: none;
}

.second-level-menu > li
{
    position: relative;
    height: 30px;
    background: #999999;
}
.second-level-menu > li:hover { background: #CCCCCC; }

.top-level-menu
{
    list-style: none;
    padding: 0;
    margin: 0;
}

.top-level-menu > li
{
    position: relative;
    float: left;
    height: 30px;
    width: 150px;
    background: #999999;
}
.top-level-menu > li:hover { background: #CCCCCC; }

.top-level-menu li:hover > ul
{
    /* On hover, display the next level's menu */
    display: inline;
}


/* Menu Link Styles */

.top-level-menu a /* Apply to all links inside the multi-level menu */
{
    font: bold 14px Arial, Helvetica, sans-serif;
    color: #FFFFFF;
    text-decoration: none;
    padding: 0 0 0 10px;

    /* Make the link cover the entire list item-container */
    display: block;
    line-height: 30px;
}
.top-level-menu a:hover { color: #000000; }

/* Responsive layout - when the screen is less than 700px wide, make the two columns stack on top of each other instead of next to each other */
@media screen and (max-width: 700px) {
  .row {   
    flex-direction: column;
  }
}

/* Responsive layout - when the screen is less than 400px wide, make the navigation links stack on top of each other instead of next to each other */
@media screen and (max-width: 400px) {
  .navbar a {
    float: none;
    width: 100%;
  }
}
</style>
</head>
<body onload="selectDefault()">
<div class="header">
  <h1>Work</h1>
  <p>Projects</p>
</div>

<div class="navbar">
  <a href="index.html" >Home</a>
  <a href="work.html" class="active">Work</a>
  <a href="extracurs.html">Extra-curriculars</a>
  <a href="hobbies.html">Hobbies/Interests</a>
</div>
<ul class="top-level-menu">
    <li>
    	<a href="#">Java</a>
    	<ul class="second-level-menu">
    		<li>
    			<a href="inspector.html">Reflective Object Inspector</a>
    			<ul class="third-level-menu">
    				<li><a href="#" id="ins">Inspector.java</li>
					<li><a href="#" id="ri">ReflectiveInspector.java</li>
					<li><a href="#" id="it">InspectorTest.java</li>
    			</ul>
    		</li>
    	</ul>
    </li>
    <li>
    	<a href="#">Python</a>
    </li>
</ul>
<div>
<pre>
	<code class="java" id="javaSec">
		Test
	</code>
</pre>
</div>
<script>
function openCity(evt, cityName) {
  // Declare all variables
  var i, tabcontent, tablinks;

  // Get all elements with class="tabcontent" and hide them
  tabcontent = document.getElementsByClassName("tabcontent");
  for (i = 0; i < tabcontent.length; i++) {
    tabcontent[i].style.display = "none";
  }

  // Get all elements with class="tablinks" and remove the class "active"
  tablinks = document.getElementsByClassName("tablinks");
  for (i = 0; i < tablinks.length; i++) {
    tablinks[i].className = tablinks[i].className.replace(" active", "");
  }

  // Show the current tab, and add an "active" class to the link that opened the tab
  document.getElementById(cityName).style.display = "block";
  evt.currentTarget.className += " active";
} 
</script>
<script>
function openCity2(evt, cityName) {
  // Declare all variables
  var i, tabcontent, tablinks;

  // Get all elements with class="tabcontent" and hide them
  tabcontent = document.getElementsByClassName("tabcontent2");
  for (i = 0; i < tabcontent.length; i++) {
    tabcontent[i].style.display = "none";
  }

  // Get all elements with class="tablinks" and remove the class "active"
  tablinks = document.getElementsByClassName("tablinks2");
  for (i = 0; i < tablinks.length; i++) {
    tablinks[i].className = tablinks[i].className.replace(" active", "");
  }

  // Show the current tab, and add an "active" class to the link that opened the tab
  document.getElementById(cityName).style.display = "block";
  evt.currentTarget.className += " active";
} 
</script>
<script type="text/javascript">
	function selectDefault(){
		document.getElementById("defaultOpen").click();
		document.getElementById("defaultOpen2").click();
	}
</script>
<div class="footer">
  <h2>Footer</h2>
</div>
</body>
</html>
